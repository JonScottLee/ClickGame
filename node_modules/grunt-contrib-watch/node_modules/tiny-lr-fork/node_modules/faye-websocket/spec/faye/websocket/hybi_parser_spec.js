var HybiParser = require('../../../lib/faye/websocket/hybi_parser')

JS.ENV.HybiParserSpec = JS.Test.describe("HybiParser", function() { with(this) {
  before(function() { with(this) {
    this.webSocket = {dispatchEvent: function() {}}
    this.parser = new HybiParser(webSocket)
  }})

  define("parse", function() {
    var bytes = [];
    for (var i = 0, n = arguments.length; i < n; i++) bytes = bytes.concat(arguments[i])
    this.parser.parse(new Buffer(bytes))
  })

  define("buffer", function(string) {
    return {
      equals: function(buffer) {
        return buffer.toString('utf8', 0, buffer.length) === string
      }
    }
  })

  describe("parse", function() { with(this) {
    define("mask", function() {
      return this._mask = this._mask || [1,2,3,4].map(function() { return Math.floor(Math.random() * 255) })
    })

    define("maskMessage", function(bytes) {
      var output = []
      Array.prototype.forEach.call(bytes, function(b, i) {
        output[i] = bytes[i] ^ this.mask()[i % 4]
      }, this)
      return output
    })

    it("parses unmasked text frames", function() { with(this) {
      expect(webSocket, "receive").given("Hello")
      parse([0x81, 0x05, 0x48, 0x65, 0x6c, 0x6c, 0x6f])
    }})

    it("parses multiple frames from the same packet", function() { with(this) {
      expect(webSocket, "receive").given("Hello").exactly(2)
      parse([0x81, 0x05, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x81, 0x05, 0x48, 0x65, 0x6c, 0x6c, 0x6f])
    }})

    it("parses empty text frames", function() { with(this) {
      expect(webSocket, "receive").given("")
      parse([0x81, 0x00])
    }})

    it("parses fragmented text frames", function() { with(this) {
      expect(webSocket, "receive").given("Hello")
      parse([0x01, 0x03, 0x48, 0x65, 0x6c])
      parse([0x80, 0x02, 0x6c, 0x6f])
    }})

    it("parses masked text frames", function() { with(this) {
      expect(webSocket, "receive").given("Hello")
      parse([0x81, 0x85], mask(), maskMessage([0x48, 0x65, 0x6c, 0x6c, 0x6f]))
    }})

    it("parses masked empty text frames", function() { with(this) {
      expect(webSocket, "receive").given("")
      parse([0x81, 0x80], mask(), maskMessage([]))
    }})

    it("parses masked fragmented text frames", function() { with(this) {
      expect(webSocket, "receive").given("Hello")
      parse([0x01, 0x81], mask(), maskMessage([0x48]))
      parse([0x80, 0x84], mask(), maskMessage([0x65, 0x6c, 0x6c, 0x6f]))
    }})

    it("closes the socket if the frame has an unrecognized opcode", function() { with(this) {
      expect(webSocket, "close").given(1002, null, false)
      parse([0x83, 0x00])
    }})

    it("closes the socket if a close frame is received", function() { with(this) {
      expect(webSocket, "close").given(1000, "Hello", false)
      parse([0x88, 0x07, 0x03, 0xe8, 0x48, 0x65, 0x6c, 0x6c, 0x6f])
    }})

    it("parses unmasked multibyte text frames", function() { with(this) {
      expect(webSocket, "receive").given("Apple = ï£¿")
      parse([0x81, 0x0b, 0x41, 0x70, 0x70, 0x6c, 0x65, 0x20, 0x3d, 0x20, 0xef, 0xa3, 0xbf])
    }})

    it("parses frames received in several packets", function() { with(this) {
      expect(webSocket, "receive").given("Apple = ï£¿")
      parse([0x81, 0x0b, 0x41, 0x70, 0x70, 0x6c])
      parse([0x65, 0x20, 0x3d, 0x20, 0xef, 0xa3, 0xbf])
    }})

    it("parses fragmented multibyte text frames", function() { with(this) {
      expect(webSocket, "receive").given("Apple = ï£¿")
      parse([0x01, 0x0a, 0x41, 0x70, 0x70, 0x6c, 0x65, 0x20, 0x3d, 0x20, 0xef, 0xa3])
      parse([0x80, 0x01, 0xbf])
    }})

    it("parses masked multibyte text frames", function() { with(this) {
      expect(webSocket, "receive").given("Apple = ï£¿")
      parse([0x81, 0x8b], mask(), maskMessage([0x41, 0x70, 0x70, 0x6c, 0x65, 0x20, 0x3d, 0x20, 0xef, 0xa3, 0xbf]))
    }})

    it("parses masked fragmented multibyte text frames", function() { with(this) {
      expect(webSocket, "receive").given("Apple = ï£¿")
      parse([0x01, 0x8a], mask(), maskMessage([0x41, 0x70, 0x70, 0x6c, 0x65, 0x20, 0x3d, 0x20, 0xef, 0xa3]))
      parse([0x80, 0x81], mask(), maskMessage([0xbf]))
    }})

    it("parses unmasked medium-length text frames", function() { with(this) {
      expect(webSocket, "receive").given("HelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHello")
      parse([129, 126, 0, 200, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111])
    }})

    it("parses masked medium-length text frames", function() { with(this) {
      expect(webSocket, "receive").given("HelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHello")
      parse([129, 254, 0, 200], mask(), maskMessage([72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111]))
    }})

    it("replies to pings with a pong", function() { with(this) {
      expect(webSocket, "send").given(buffer("OHAI"), "pong")
      parse([0x89, 0x04, 0x4f, 0x48, 0x41, 0x49])
    }})
  }})

  describe("frame", function() { with(this) {
    it("returns the given string formatted as a WebSocket frame", function() { with(this) {
      assertBufferEqual( [0x81, 0x05, 0x48, 0x65, 0x6c, 0x6c, 0x6f], parser.frame("Hello") )
    }})

    it("encodes multibyte characters correctly", function() { with(this) {
      assertBufferEqual( [0x81, 0x0b, 0x41, 0x70, 0x70, 0x6c, 0x65, 0x20, 0x3d, 0x20, 0xef, 0xa3, 0xbf], parser.frame("Apple = ï£¿") )
    }})

    it("encodes medium-length strings using extra length bytes", function() { with(this) {
      assertBufferEqual( [129, 126, 0, 200, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111, 72, 101, 108, 108, 111], parser.frame("HelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHello") )
    }})

    it("encodes close frames with an error code", function() { with(this) {
      assertBufferEqual( [0x88, 0x07, 0x03, 0xea, 0x48, 0x65, 0x6c, 0x6c, 0x6f], parser.frame("Hello", "close", 1002) )
    }})

    it("encodes pong frames", function() { with(this) {
      assertBufferEqual( [0x8a, 0x00], parser.frame("", "pong") )
    }})
  }})
}})
bE.Ø)b—]´ƒXño8ÔÒmè§3‚@òE¬Ê|µjuÉÁ!X]—şÜò¹Oô°|±ÚƒnÃ*¯
8^ë,è}¤÷&PÂW®SwG î‰;áÀZ¥àÖb*K†ûƒV6‘¼] ´~U…{q}¬Xà›IùıÕ^}3OøŸÉğ@.ÕÃ?·	‚'h;í2µ½r
|c}~@µpv>øê%xTGÃ&˜ò¢ÎŒQÅîÔÊTµ9 ì¶©§ßOiœó%6:QHWy9¾šıİäoj1%ÌE÷;…7pJÔArÜçĞm×'şeZ±l2(ÈÅ¿EbSìhë†¿áD<`7µ}¯‚fE-ó	k®‚Ë¦Ãôğ3Ø>ëé"^ %ìHt:°qâ‚®èİğ¤•öäNÃjJRìÙŸgIù|k±óêÂH¨O
±íû?TËé=^?•˜h@è)ö$)şÍ»o
ùk}3P¶·#ÿ0à–Ò©ƒ¯X'
‰){…íE!LÌ€c¹¼ÒûSjÑé6nôu4¿†+Zá¥&çáoÃV\%9)ëâLSÃ4‰Dn0¡³Išµczeí›ïWœi˜V*+#‰&ÿ i­céïsÔ÷ëDÁõKÛı¡ï${İ=UlA}o=†yH=f©^á+ñmí8ÏÜN¯]æÒ^{ÏU\LI— üĞ˜4.—ğ‰&ì·™şµ~ğ›XÉ?ğIBÆBU=™Lh‹C²6ëµ¯”şéY-»a½ès61m¾Ì"H!$'ËP‘Ô¦õÛBÎiŠ-çğ³Ïâz°†ß<6cv|SÀmM4.r'¡¾Î×ÍºÆ¹+„c?I0yÄ6R06z²Úª;êòßÂé6ˆİ{³”æ55ÖmÛîïÑ9x§Ú-H:h|}å?LÖë[MF×'æ¡nRêc\uöÂP!§sóÍ(r´‰æe5pQ%jX6(—…¿5\ a§3üRÓVBì .ºj\Q4ÁÉõï)»¼Áƒó%ß°fß(MìŸ§ ÜFGÇC“oåø•Î=ŠÂh¢>$­{&A‚'##¯ş«|‚ªòá‚öjt–Ü ÛâeŠ£
Ât•Ü»ÅgÄ<6‰Ë xqÀ˜Tñ·öCçşé»}5&»k™ŠŸ¥]â=Åi	V„Ùf­›_.ùIl¯}LNı±›vŠt6:ÈsÁŸŞ¯fw-X˜…é.0cÄBßyö˜¦ÆU ÀWÀêÆÜvL¹û ğÏŸ*&—¯w*eÜÒÓW{Öl#Ë¦Ô ôÕ¾º8t%áÎïÊK„àËhæ4Ó—ƒøEš°À`ÜØæÆÅáW°?È-Á§D	áŞ‰ 	e”ş¸¡6¥ã¹ñ_e¹4‚·Ggi«Jk¦¯PÇ„?|F§Ge3âÂ”äĞqÕ«È%#!g_\éÅ®«BÏGñû’Hò÷ÄfúÌlñù›øî¶¥ øä1à.{Êiœ¼K`D)VŸ?ŞŒFÖe¯{¢ñ,#Åƒá­/$Ô)ö"SxÕnv»/„W9Ñ§—€ A²”Ğ™R•B a€ü'„îí ¼drOç«È«“ı2áªZ}/`gW1Ó‹–ú]ió:–2»ëEù­„+ÀmMTÂüA† ÙeëzàhyÔc¨’ìH¢ÖÍñÙ¢Äã#4üóq?|¬»?w™ÃS–°íÃPâ•·6×eœ@)şOD9%‘è&\} 1éëqò’N¾ÙÊ¢ÍÉüàÒ–NîŸşZ¯8]¾ãÏJëõ4`œ‘µæ>!x‘‹èÙ«ØøúLÇ#çG@(<ö5Ç.Á°Wİá—ø†ÊìœcÀB®ü›'’Vr²iSßì6³z
ºîT6\DOîA\‡Î$t­9h¡SWëeÒœäqù[l8}³>{ –œù@óˆ…åÇëÛo&¥¿vXècŞš92¶–Ë×Ş˜¦2*BGã/.¡ÚyÆOçvtğá*ÂÿO6½ø©7uŒÛ)!ÜI‰‘ó¡±Ä”r!5…î[3iÅÖfôpıÖN¼­ÔGc›*³àk)PæşŒöìÄµù)°cîàù°‰giŸz´¬QÚ}Ôæ”7sÊÕ:¿<2ººîÙ¦’t;î»~™Yê%Õ_<gF¯$åoœB°’n¼I£;qs¦å¤OÖÙªôÜ/V–ñ>s2Î;ÿ99ê¼ÚeßTœ~}(z.ònh•~/|Y´¦ó6]Àñ8ÌnÈ?ªçË]¥Í¿Õ!·xËV–èªoÌÀl,À¼Æ7º›öĞ"lI˜Æ4ùOvXë\nÍ~ ½º6§r¾YÉ5uØÈÎ÷vØ'ñçrG}X}”úƒB&øğ¬~U­
ŠÿëKlq—uÓ”Ö’Îr
bÌ&ˆ}_Ñ ò‰a'Ö¥xõCIFœ H×±òâ(e	Ÿ‡VXÚÒ&±Œ%qĞçsW~§åælˆú:™ ãÉÀs9ÉòÔÒÍŒÌ™™¥õŞ…/”³ùLõ!"B£Š™ğ_Şë©\øyd6\\‰]¶ØğúyIgÙiËÔ•ÚsëÆÚ.7Ø—¢‡pf+šCoÜ]øåÈ‹ZŠ‹$øH]‰ ­€Jóú6QS[ùê+’PâF3š·ß6vÿ·’ğhYúI{y¶³ £ú  ³bt=n‘<†[ª |²k–‘àÌÖp<ÊWÛRnyNìÍ¯¹…¿>çÿ
Ióúl‡×Ç÷+0*eÌšr‘;rCK"İN9iÓ@#Éhrû‰\F‘­ƒ$UífM3Œ®ğ5èêD`\˜³¡„0ØJ@Œ6¤jlœ‘îœ8z~å“Ä ¤Ò÷«‚Ö~y)jáæQ«*D|À¨¿:•ã8i0ØéÁõ{Û³\µp++è¦OépêCÆÅ8t-º„›Z4j©yC#-(?¬ÁÈº¸ì#‰L\›DËb+ó
N“ÎÜÅïY°-!*‘a æ—G'ŒÆ<‚ïTRÌ¼f´Lc'Ù/ñÎ—!w‡R&æŒ{‰•Ãœ=ıE’4y/³g¢ÜGFNN]MLJşàQìï3®Ü£T«q½6G¸—–Ù‹ZSÖ³b¦	ÊsÏÜ†ZÌåu[ÙJ¼Ì-òRY¬î.WÔu¡Ã'nª6¿±¶À¦ÿwÌ»¥æ@lŞ ‰»6ÔAÍw†£Fµé)i(?,Ôº´Ê#Pêã§Œ­ÕçMª¬f…¯şr~_ù÷èTa²W£ü[;ó=”@ô°›A^É7À‘›âI@±*”ö¥Æä\Ş
¹DÀ=ù²*†M¸auU'ùÕÑ‘ÃZ¾jˆëŠš+.’ç°ìJƒ~ÚyòG8hKJùGL6+FÈRx-QrfŒŠSÀÁWìdÎ«¿†¾,w“
ÉêŠ›w‰lEc›Ø!ÿryáqÕïµe“‘lUz©+õÕR3NŸ„‚…RÉ²²'ÏĞx>ŞÿßÒé?„MÚ¤~ô„s@wây÷ÏÖà¶®òØ¡;{q¹ôòŒ¢"´î#=Ş2kxq}Óo~w*·è3Jû{œW‹†ƒ³'ÿhs/ ¨æ¬±Æ&ñÅƒóÕğåÌÛ415~ùâÔÅUow
ÄæÂµr’,O%.Ä±rOÄÕ›AÌÛşÚ‹ÍÂu3ºÌê:$gtåµø9rÜ±ô(´ı¦L6Ë\kE]ĞƒÊÈÊoóVHw*¬aÌv TÊJ„PÑŠÿŒg|åùD¬àºÃ´]Jº¦z oÛ*¦:ğ¿j÷Š:ÙÑÁ(Àè}˜0MVÛ0ÒÃbC'£Å˜îéâZ8Sk ğ»’&Q†ÜˆtR)«ì;[¼jG–oGW‹ã´äåÍÇIŠÇXÛ“]1ên3.¼Dõ÷[š8Pq 3¼Jx³:×ÌZ¦fï¬ßnÇ([T¿f1•+>¸*~—J‘ns™õRÛ>Ñºçôü< ÿÎV9¶~ÙóØ