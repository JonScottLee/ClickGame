'use strict';

var util = require('../');

var fs = require('fs');
var path = require('path');

var Tempfile = require('temporary/lib/file');

exports['util.callbackify'] = {
  'return': function(test) {
    test.expect(1);
    // This function returns a value.
    function add(a, b) {
      return a + b;
    }
    util.callbackify(add)(1, 2, function(result) {
      test.equal(result, 3, 'should be the correct result.');
      test.done();
    });
  },
  'callback (sync)': function(test) {
    test.expect(1);
    // This function accepts a callback which it calls synchronously.
    function add(a, b, done) {
      done(a + b);
    }
    util.callbackify(add)(1, 2, function(result) {
      test.equal(result, 3, 'should be the correct result.');
      test.done();
    });
  },
  'callback (async)': function(test) {
    test.expect(1);
    // This function accepts a callback which it calls asynchronously.
    function add(a, b, done) {
      setTimeout(done.bind(null, a + b), 0);
    }
    util.callbackify(add)(1, 2, function(result) {
      test.equal(result, 3, 'should be the correct result.');
      test.done();
    });
  }
};

exports['util'] = {
  'error': function(test) {
    test.expect(9);
    var origError = new Error('Original error.');

    var err = util.error('Test message.');
    test.ok(err instanceof Error, 'Should be an Error.');
    test.equal(err.name, 'Error', 'Should be an Error.');
    test.equal(err.message, 'Test message.', 'Should have the correct message.');

    err = util.error('Test message.', origError);
    test.ok(err instanceof Error, 'Should be an Error.');
    test.equal(err.name, 'Error', 'Should be an Error.');
    test.equal(err.message, 'Test message.', 'Should have the correct message.');
    test.equal(err.origError, origError, 'Should reflect the original error.');

    var newError = new Error('Test message.');
    err = util.error(newError, origError);
    test.equal(err, newError, 'Should be the passed-in Error.');
    test.equal(err.origError, origError, 'Should reflect the original error.');
    test.done();
  },
  'linefeed': function(test) {
    test.expect(1);
    if (process.platform === 'win32') {
      test.equal(util.linefeed, '\r\n', 'linefeed should be operating-system appropriate.');
    } else {
      test.equal(util.linefeed, '\n', 'linefeed should be operating-system appropriate.');
    }
    test.done();
  },
  'normalizelf': function(test) {
    test.expect(1);
    if (process.platform === 'win32') {
      test.equal(util.normalizelf('foo\nbar\r\nbaz\r\n\r\nqux\n\nquux'), 'foo\r\nbar\r\nbaz\r\n\r\nqux\r\n\r\nquux', 'linefeeds should be normalized');
    } else {
      test.equal(util.normalizelf('foo\nbar\r\nbaz\r\n\r\nqux\n\nquux'), 'foo\nbar\nbaz\n\nqux\n\nquux', 'linefeeds should be normalized');
    }
    test.done();
  }
};

exports['util.spawn'] = {
  setUp: function(done) {
    this.script = path.resolve('test/fixtures/spawn.js');
    done();
  },
  'exit code 0': function(test) {
    test.expect(6);
    util.spawn({
      cmd: process.execPath,
      args: [ this.script, 0 ],
    }, function(err, result, code) {
      test.equals(err, null);
      test.equals(code, 0);
      test.equals(result.stdout, 'stdout');
      test.equals(result.stderr, 'stderr');
      test.equals(result.code, 0);
      test.equals(String(result), 'stdout');
      test.done();
    });
  },
  'exit code 0, fallback': function(test) {
    test.expect(6);
    util.spawn({
      cmd: process.execPath,
      args: [ this.script, 0 ],
      fallback: 'ignored if exit code is 0'
    }, function(err, result, code) {
      test.equals(err, null);
      test.equals(code, 0);
      test.equals(result.stdout, 'stdout');
      test.equals(result.stderr, 'stderr');
      test.equals(result.code, 0);
      test.equals(String(result), 'stdout');
      test.done();
    });
  },
  'non-zero exit code': function(test) {
    test.expect(7);
    util.spawn({
      cmd: process.execPath,
      args: [ this.script, 123 ],
    }, function(err, result, code) {
      test.ok(err instanceof Error);
      test.equals(err.message, 'stderr');
      test.equals(code, 123);
      test.equals(result.stdout, 'stdout');
      test.equals(result.stderr, 'stderr');
      test.equals(result.code, 123);
      test.equals(String(result), 'stderr');
      test.done();
    });
  },
  'non-zero exit code, fallback': function(test) {
    test.expect(6);
    util.spawn({
      cmd: process.execPath,
      args: [ this.script, 123 ],
      fallback: 'custom fallback'
    }, function(err, result, code) {
      test.equals(err, null);
      test.equals(code, 123);
      test.equals(result.stdout, 'stdout');
      test.equals(result.stderr, 'stderr');
      test.equals(result.code, 123);
      test.equals(String(result), 'custom fallback');
      test.done();
    });
  },
  'cmd not found': function(test) {
    test.expect(3);
    util.spawn({
      cmd: 'nodewtfmisspelled',
    }, function(err, result, code) {
      test.ok(err instanceof Error);
      test.equals(code, 127);
      test.equals(result.code, 127);
      test.done();
    });
  },
  'cmd not found, fallback': function(test) {
    test.expect(4);
    util.spawn({
      cmd: 'nodewtfmisspelled',
      fallback: 'use a fallback or good luck'
    }, function(err, result, code) {
      test.equals(err, null);
      test.equals(code, 127);
      test.equals(result.code, 127);
      test.equals(String(result), 'use a fallback or good luck');
      test.done();
    });
  },
  'cmd not in path': function(test) {
    test.expect(6);
    var win32 = process.platform === 'win32';
    util.spawn({
      cmd: 'test\\fixtures\\exec' + (win32 ? '.cmd' : '.sh'),
    }, function(err, result, code) {
      test.equals(err, null);
      test.equals(code, 0);
      test.equals(result.stdout, 'done');
      test.equals(result.stderr, '');
      test.equals(result.code, 0);
      test.equals(String(result), 'done');
      test.done();
    });
  },
  'cmd not in path (with cwd)': function(test) {
    test.expect(6);
    var win32 = process.platform === 'win32';
    util.spawn({
      cmd: './exec' + (win32 ? '.cmd' : '.sh'),
      opts: {cwd: 'test/fixtures'},
    }, function(err, result, code) {
      test.equals(err, null);
      test.equals(code, 0);
      test.equals(result.stdout, 'done');
      test.equals(result.stderr, '');
      test.equals(result.code, 0);
      test.equals(String(result), 'done');
      test.done();
    });
  },
  'grunt': function(test) {
    test.expect(3);
    util.spawn({
      grunt: true,
      args: [ '--gruntfile', 'test/fixtures/Gruntfile-print-text.js', 'print:foo' ],
    }, function(err, result, code) {
      test.equals(err, null);
      test.equals(code, 0);
      test.ok(/^OUTPUT: foo/m.test(result.stdout), 'stdout should contain output indicating the grunt task was run.');
      test.done();
    });
  },
  'grunt (with cwd)': function(test) {
    test.expect(3);
    util.spawn({
      grunt: true,
      args: [ '--gruntfile', 'Gruntfile-print-text.js', 'print:foo' ],
      opts: {cwd: 'test/fixtures'},
    }, function(err, result, code) {
      test.equals(err, null);
      test.equals(code, 0);
      test.ok(/^OUTPUT: foo/m.test(result.stdout), 'stdout should contain output indicating the grunt task was run.');
      test.done();
    });
  },
  'grunt passes execArgv': function(test) {
    test.expect(3);
    util.spawn({
      cmd: process.execPath,
      args: [ '--harmony', process.argv[1], '--gruntfile', 'test/fixtures/Gruntfile-execArgv.js'],
    }, function(err, result, code) {
      test.equals(err, null);
      test.equals(code, 0);
      test.ok(/^OUTPUT: --harmony/m.test(result.stdout), 'stdout should contain passed-through process.execArgv.');
      test.done();
    });
  },
  'grunt result.toString() with error': function(test) {
    // grunt.log.error uses standard out, to be fixed in 0.5.
    test.expect(4);
    util.spawn({
      grunt: true,
      args: [ 'nonexistentTask' ]
    }, function(err, result, code) {
      test.ok(err instanceof Error, 'Should be an Error.');
      test.equal(err.name, 'Error', 'Should be an Error.');
      test.equals(code, 3);
      test.ok(/Warning: Task "nonexistentTask" not found./m.test(result.toString()), 'stdout should contain output indicating the grunt task was (attempted to be) run.');
      test.done();
    });
  },
  'custom stdio stream(s)': function(test) {
    test.expect(6);
    var stdoutFile = new Tempfile();
    var stderrFile = new Tempfile();
    var stdout = fs.openSync(stdoutFile.path, 'a');
    var stderr = fs.openSync(stderrFile.path, 'a');
    var child = util.spawn({
      cmd: process.execPath,
      args: [ this.script, 0 ],
      opts: {stdio: [null, stdout, stderr]},
    }, function(err, result, code) {
      test.equals(code, 0);
      test.equals(String(fs.readFileSync(stdoutFile.path)), 'stdout\n', 'Child process stdout should have been captured via custom stream.');
      test.equals(String(fs.readFileSync(stderrFile.path)), 'stderr\n', 'Child process stderr should have been captured via custom stream.');
      stdoutFile.unlinkSync();
      stderrFile.unlinkSync();
      test.equals(result.stdout, '', 'Nothing will be passed to the stdout string when spawn stdio is a custom stream.');
      test.done();
    });
    test.ok(!child.stdout, 'child should not have a stdout property.');
    test.ok(!child.stderr, 'child should not have a stderr property.');
  },
};

exports['util.spawn.multibyte'] = {
  setUp: function(done) {
    this.script = path.resolve('test/fixtures/spawn-multibyte.js');
    done();
  },
  'partial stdout': function(test) {
    test.expect(4);
    util.spawn({
      cmd: process.execPath,
      args: [ this.script ],
    }, function(err, result, code) {
      test.equals(err, null);
      test.equals(code, 0);
      test.equals(result.stdout, 'ã“ã‚“ã«ã¡ã¯');
      test.equals(result.stderr, 'ã“ã‚“ã«ã¡ã¯');
      test.done();
    });
  }
};

exports['util.underscore.string'] = function(test) {
  test.expect(4);
  test.equals(util._.trim('    foo     '), 'foo', 'Should have trimmed the string.');
  test.equals(util._.capitalize('foo'), 'Foo', 'Should have capitalized the first letter.');
  test.equals(util._.words('one two three').length, 3, 'Should have counted three words.');
  test.ok(util._.isBlank(' '), 'Should be blank.');
  test.done();
};

function getType(val) {
  if (Buffer.isBuffer(val)) { return 'buffer'; }
  return Object.prototype.toString.call(val).slice(8, -1).toLowerCase();
}

exports['util.recurse'] = {
  setUp: function(done) {
    this.typeValue = function(value) {
      return {
        value: value,
        type: getType(value),
      };
    };
    done();
  },
  'primitives': function(test) {
    test.expect(1);
    var actual = util.recurse({
      bool: true,
      num: 1,
      str: 'foo',
      nul: null,
      undef: undefined,
    }, this.typeValue);
    var expected = {
      bool: {type: 'boolean', value: true},
      num: {type: 'number', value: 1},
      str: {type: 'string', value: 'foo'},
      nul: {type: 'null', value: null},
      undef: {type: 'undefined', value: undefined},
    };
    test.deepEqual(actual, expected, 'Should process primitive values.');
    test.done();
  },
  'array': function(test) {
    test.expect(1);
    var actual = util.recurse({
      arr: [
        true,
        1,
        'foo',
        null,
        undefined,
        [
          true,
          1,
          'foo',
          null,
          undefined,
        ],
      ],
    }, this.typeValue);
    var expected = {
      arr: [
        {type: 'boolean', value: true},
        {type: 'number', value: 1},
        {type: 'string', value: 'foo'},
        {type: 'null', value: null},
        {type: 'undefined', value: undefined},
        [
          {type: 'boolean', value: true},
          {type: 'number', value: 1},
          {type: 'string', value: 'foo'},
          {type: 'null', value: null},
          {type: 'undefined', value: undefined},
        ],
      ],
    };
    test.deepEqual(actual, expected, 'Should recurse over arrays.');
    test.done();
  },
  'object': function(test) {
    test.expect(1);
    var actual = util.recurse({
      obj: {
        bool: true,
        num: 1,
        str: 'foo',
        nul: null,
        undef: undefined,
        obj: {
          bool: true,
          num: 1,
          str: 'foo',
          nul: null,
          undef: undefined,
        },
      },
    }, this.typeValue);
    var expected = {
      obj: {
        bool: {type: 'boolean', value: true},
        num: {type: 'number', value: 1},
        str: {type: 'string', value: 'foo'},
        nul: {type: 'null', value: null},
        undef: {type: 'undefined', value: undefined},
        obj: {
          bool: {type: 'boolean', value: true},
          num: {type: 'number', value: 1},
          str: {type: 'string', value: 'foo'},
          nul: {type: 'null', value: null},
          undef: {type: 'undefined', value: undefined},
        },
      },
    };
    test.deepEqual(actual, expected, 'Should recurse over objects.');
    test.done();
  },
  'array in object': function(test) {
    test.expect(1);
    var actual = util.recurse({
      obj: {
        arr: [
          true,
          1,
          'foo',
          null,
          undefined,
        ],
      },
    }, this.typeValue);
    var expected = {
      obj: {
        arr: [
          {type: 'boolean', value: true},
          {type: 'number', value: 1},
          {type: 'string', value: 'foo'},
          {type: 'null', value: null},
          {type: 'undefined', value: undefined},
        ],
      },
    };
    test.deepEqual(actual, expected, 'Should recurse over arrays in objects.');
    test.done();
  },
  'object in array': function(test) {
    test.expect(1);
    var actual = util.recurse({
      arr: [
        true,
        {
          num: 1,
          str: 'foo',
        },
        null,
        undefined,
      ],
    }, this.typeValue);
    var expected = {
      arr: [
        {type: 'boolean', value: true},
        {
          num: {type: 'number', value: 1},
          str: {type: 'string', value: 'foo'},
        },
        {type: 'null', value: null},
        {type: 'undefined', value: undefined},
      ],
    };
    test.deepEqual(actual, expected, 'Should recurse over objects in arrays.');
    test.done();
  },
  'buffer': function(test) {
    test.expect(1);
    var actual = util.recurse({
      buf: new Buffer('buf'),
    }, this.typeValue);
    var expected = {
      buf: {type: 'buffer', value: new Buffer('buf')},
    };
    test.deepEqual(actual, expected, 'Should not mangle Buffer instances.');
    test.done();
  },
  'inherited properties': function(test) {
    test.expect(1);
    var actual = util.recurse({
      obj: Object.create({num: 1}, {
        str: {value: 'foo', enumerable: true},
        ignored: {value: 'ignored', enumerable: false},
      }),
    }, this.typeValue);
    var expected = {
      obj: {
        num: {type: 'number', value: 1},
        str: {type: 'string', value: 'foo'},
      }
    };
    test.deepEqual(actual, expected, 'Should enumerate inherited object properties.');
    test.done();
  },
  'circular references': function(test) {
    test.expect(6);
    function assertErrorWithPath(expectedPath) {
      return function(actual) {
        return actual.path === expectedPath &&
          actual.message === 'Circular reference detected (' + expectedPath + ')';
      };
    }
    test.doesNotThrow(function() {
      var obj = {
        // wat
        a:[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],
        // does
        b:[[[[],[[[],[[[[],[[[],[[[],[[[],[[[],[[[[],[[]]]]]]]]]]]]]]]]]]]]],
        // it
        c:{d:{e:{f:{g:{h:{i:{j:{k:{l:{m:{n:{o:{p:{q:{r:{s:{}}}}}}}}}}}}}}}}},
        // mean
        t:[{u:[{v:[[[[],[[[],[[[{w:[{x:[[[],[[[{y:[[1]]}]]]]]}]}]]]]]]]]}]}],
      };
      util.recurse(obj, function(v) { return v; });
    }, 'Should not throw when no circular reference is detected.');
    test.throws(function() {
      var obj = {a: 1, b: 2};
      obj.obj = obj;
      util.recurse(obj, function(v) { return v; });
    }, assertErrorWithPath('.obj'), 'Should throw when a circular reference is detected.');
    test.throws(function() {
      var obj = {a:{'b b':{'c-c':{d_d:{e:{f:{g:{h:{i:{j:{k:{l:{}}}}}}}}}}}}};
      obj.a['b b']['c-c'].d_d.e.f.g.h.i.j.k.l.obj = obj;
      util.recurse(obj, function(v) { return v; });
    }, assertErrorWithPath('.a["b b"]["c-c"].d_d.e.f.g.h.i.j.k.l.obj'), 'Should throw when a circular reference is detected.');
    test.throws(function() {
      var obj = {a: 1, b: 2};
      obj.arr = [1, 2, obj, 3, 4];
      util.recurse(obj, function(v) { return v; });
    }, assertErrorWithPath('.arr[2]'), 'Should throw when a circular reference is detected.');
    test.throws(function() {
      var obj = {a: 1, b: 2};
      obj.arr = [{a:[1,{b:[2,{c:[3,obj,4]},5]},6]},7];
      util.recurse(obj, function(v) { return v; });
    }, assertErrorWithPath('.arr[0].a[1].b[1].c[1]'), 'Should throw when a circular reference is detected.');
    test.throws(function() {
      var obj = {a: 1, b: 2};
      obj.arr = [];
      obj.arr.push(0,{a:[1,{b:[2,{c:[3,obj.arr,4]},5]},6]},7);
      util.recurse(obj, function(v) { return v; });
    }, assertErrorWithPath('.arr[1].a[1].b[1].c[1]'), 'Should throw when a circular reference is detected.');
    test.done();
  },
};
ÿ? á9RœÉüºl<¾ëD'ğNÕ•("LR‚&¨©ê¬µQ2åİêÆ÷)ı-ïcğw]¬¾pÊë°EöS&ãÙ@b*
‘¤ ]k±—ßc®.òê‚=… í²ë30ÇÓ®áª²ÙÅpé48Võ¦ %QpäÓYyOæ©ó×u[×”c\¢›>F'¥vg_#1ûÚş·¾_ˆY^¡ş7%*…Èy–BÌ6äaz¯ŸÏwnJ¥÷­ÿ?–“&eQÜâ‹¬»ŸyêŒi\¡ôL'TIRÇsÅ€b#_Q¬dóØr+hÆ
¨*Ro/[xPß· Ù,vawâ¯1SO%¸4ñ‰œ™”Jô'KV¤ÿ¹[TìÀR»ŸËËü4‰‹†¹˜W Ş:¦GQkÖ5x\¾Z”S ¨KÛóÄÛlPŒÀLTè¬ÿ¿×™ÕÒök–rÁ‚d¶FöÁÒ\ôO]Y•[ìä±¥òS[ #§UqQ×ëS6<Ù¶ÄÀ’;L9½Ywƒ­˜\½w»»;TT&vŒ	É£Û¤EBÈE+?J=( d·®ÙŞ`'´Ÿò£:v ,†S-Q“°(Èz¿Àªpİ˜ôûÛgi—‹\„ÉPlÿÜ}S Ë1hÍDk¹¿ÇÁÊÍo>¼÷@øıôµkáÚ2Š‚a>=—$üru€ş£GM  32ÇºYf¨O/[W5ûÄÊ¬'¯¢:/éK¡ö¯—K‚X8'ˆ4at–ŠˆVáÕæ1›†”éÆ89 î[
xk7„eGáëJo9CoëTßú(5‘¡#¢øGñõúgZÖi1õ?E^Ë¨Åıº!j¯ôÙ!ÈöG,È]rHoïè>”4@lñûu¡Â¢Ïü­Ñ®ÿ”–M…VzÕrC…óæ£í^ò®nøË¢›ıñ¡Íä¾,NùÃø@+mñ@N_AÃ<aM!“£—À8`ª-è—Da¾j‡ÿˆ˜â‹µë£%Ô›ì!…&;iğE+BKş+×>¶]H…‚›\±K)U†JlÁ·Œ¦ßl–Š
3?@ÏßTx¶”ÚòBNğCî¡Å·`'ó1Ç4+ß’šQŸf¬4(à™|Š,…&’OS!’k``[õMÆhR3ØB¤éTóĞ†ÂßÒõPôeIUoe<à£×?K…Ü|:MÙ¾85rO­úLg¥ÿ6mÏXíf×!–3s"ûÊï£ÿz°x¥ğ2ÖÈ•¨$Ü+óïø××ÛèëÅ8å;ÎZ½ :hœu¤*ü¢7x¢ÇOÕª q£¢Éi¥Ë í4ñ<õÚ-
	©Ã&ƒWe0‰àºÌ“zàwñ"$ì‹'CåªíÂ‘ş³#Ÿ!’ó©O“åOh¨°#£	½Ä²-bşN…Õú’ƒÊ8j€™Ç—yÈÓãÕv×­<îÌ™ğµZÅ-Àû&6Å#†‰„WJ´i³ŞÇÑ6 ¾3š|}3ÁßèWA"NWwGè4^?÷ÏıæûŞÖ•¸ª+â+‰ì›‹tìïÁ&7Œ+ÊÎ?{˜æ}îøì—»7–[§ZY¶hN8—1ŠÑLÃÊÉ¿y’ÅEG2.<?KcÙhM]Ü	\Õ9ş	)ÑRC6”E~ô7+Qk.¬©ŞÛü‡œñBUSĞóÜËë9â­ÚÛ|ÕÛ-J<Tó´Ì_¶xÈ”k®Œ•Éó©É4øŒğ(¸ü4Õçi÷ŒèÀÉdT¨‚¹uP=´‡õÆ=¼ É¡¢Ğ¹ÑP€F__X_wû9ª;NCmT™äçBÎµ>!­íÆ¿bØBGŒ2°@Z¬q£ò+èµAÒ8]ë7åíô^%£‘»ŠÍŸ¥¶¨Ÿ’oÎëĞT¢ d‡U	\7> ÆA»+"˜HáYÉÚnøıÛ¨/B½£î=°(Z³—›@I¸vÜ\Ÿ)èys(>ã;ÖÖƒ0$Oğ$øvÏºt²“ğ³ôMD‡£ß“dë¨~O3ĞÑŞÄu†.ÏÕn3³½òîšØã:äğ¦àÇüa´¥µZzA”ì×¼Bæ‘râÀ„ÙèÏ ıÌÈ¬ZxØÒNjéSÔü‰šc;
«÷‹æ:´¹…ÎªÎ c™¿÷¬Ê¦_’‹ôWóÊ@Åô6ˆ{'Ö"ãaÿÁÌqÔ!éÖ,òˆ¾§íµ÷´øj Ï)AÔµ—åkhy)Õwo[ßdgdÚÎ¯ú0„@¶‡|\”wµ€ıëŠ&ù,ª¨*İ"Û©2wGL"1Dœ´çz¾è'fF'·"Š;”çÒNFcšÎêt¢÷níöÖ€­›¿šo`^mr:DnÛ_áûp?ÿk+v
‡·ƒ½pp…2•Ğr„õ†·hÓ/Jõz‘zLÍv¡~Õ.ÖHĞ¿¢]­DâsãÊ×ŞÎ÷‰Ì18é·Ã™;ÌÌ“ªx‡³Y§ZşöFÂ`î{S~V0´ºı_ã{×®hËšlCÀ™fî4ÙgŸz•¯«4A ­ñ˜ºò›T«æ›¯ÛTŒómâ}ÆS]fÜøéê³<1‹0©ÅĞ6/ëõ$»ÀˆpuñûÃ@şá×z(sæŒ®Â«•sæ§*ú;„‹v…×]èù¸kG SopäŞ*[ês§¾V>&ÉıştHÎ–
VêÍç.ÌıÄ¹t“EnÁÿï7ÒvpÑ¼ÊÔ¢ÖeÔf9‰g8ÆYoê­Œ‰yşÖ˜i†L
~CvÀ|9lâ—è‡¡f[]@Úw<©*f@ j&ît(kÎ‘2¿İM‘À‰ø¬–$=§‘H}÷ı?‹MÄ«C+kÓl÷(&GršØÕ»Ô,5£°9¶t'$:çkòíf-€<(‚ÔÎr…uŞ¿ùQE¢¼ ÿƒ´*ÔRitND>84[Ş!‹âçg	 1àè,À…ü(R}´ËØ’vEb0R=8e<ÏÃ&‚'EÑğ•¯?åyûQ-v„‰ÎHP“ìíÇ¤¿SÀ%‚¡´h4 >€F{§‹–Î}<“&U“u4[ƒw¨qï¸¦:Ğ[ÿoåÔô¢c¤•ÉÃ†éÒñæÉí­²˜¾‘…v¹WJÜ¥9õ²N“:]¾°w(ğÒœàÍf%¬³¼ÕÌ>Ü‰]0¬‰;€kıhhU^xïì2xnº­n ÿJRŒÒ(Ó 3Nëäe&î/jÚüø=±ùN"Ãu ”XµğÛÖ¥{ÿòå;`°§ûûs@ÑĞü'ßîZàwˆÎA:…e=¤Âÿ_ÿÓ…;Óø¶šë8idÇÇÀ^ªAÁÇPŒ)VWü,¡ïğˆYÛPƒŠü«a•õ‘÷ÇÈ£'zæsç>¢MşÊ6!9ƒ7ÿ»õXërğ4¯¸û?¶Fï
9&G5Ÿ/q@–ğ*Ã<5–æ5(—¸í¬É6
/d[Š—Ô(ñğúŠŸ‹_Âó²›0‚gCBgÎU“‘Æ­f0Ò”z«¶4˜«S‰lí©ö_syÓN3Na´ï?+Äu¹éĞo¨‡)¯¿Çğ<#äŞEÒóBo 6xƒëo-œyÇğ±›–åé
…R”¾ÖÏ;wò‰õR¯ğ;[0’>ò‡Ã™´hèïÇÅs0^£†xt2)[G–ÜL[Ñ“É×ÍÀ	¹WHl8ÆË=¼¡Wµkæß1<B%şñ¾c£!S!ÙÖ«öÖÿ¡y%ÂŠp2×}	SYÆéÈö&H´àJ%®l?W»;ÇgßWtßVpÑgÏlV‰fåQÌ)ÔòÈõêÒáPCÖz‚?ƒãéÈ}•æl
Yƒ¬#