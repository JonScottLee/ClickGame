// Generated by CoffeeScript 1.3.3
(function() {
  var BALANCED_PAIRS, EXPRESSION_CLOSE, EXPRESSION_END, EXPRESSION_START, IMPLICIT_BLOCK, IMPLICIT_CALL, IMPLICIT_END, IMPLICIT_FUNC, IMPLICIT_UNSPACED_CALL, INVERSES, LINEBREAKS, SINGLE_CLOSERS, SINGLE_LINERS, left, rite, _i, _len, _ref,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  exports.Rewriter = (function() {

    function Rewriter() {}

    Rewriter.prototype.rewrite = function(tokens) {
      this.tokens = tokens;
      this.removeLeadingNewlines();
      this.removeMidExpressionNewlines();
      this.closeOpenCalls();
      this.closeOpenIndexes();
      this.addImplicitIndentation();
      this.tagPostfixConditionals();
      this.addImplicitBraces();
      this.addImplicitParentheses();
      return this.tokens;
    };

    Rewriter.prototype.scanTokens = function(block) {
      var i, token, tokens;
      tokens = this.tokens;
      i = 0;
      while (token = tokens[i]) {
        i += block.call(this, token, i, tokens);
      }
      return true;
    };

    Rewriter.prototype.detectEnd = function(i, condition, action) {
      var levels, token, tokens, _ref, _ref1;
      tokens = this.tokens;
      levels = 0;
      while (token = tokens[i]) {
        if (levels === 0 && condition.call(this, token, i)) {
          return action.call(this, token, i);
        }
        if (!token || levels < 0) {
          return action.call(this, token, i - 1);
        }
        if (_ref = token[0], __indexOf.call(EXPRESSION_START, _ref) >= 0) {
          levels += 1;
        } else if (_ref1 = token[0], __indexOf.call(EXPRESSION_END, _ref1) >= 0) {
          levels -= 1;
        }
        i += 1;
      }
      return i - 1;
    };

    Rewriter.prototype.removeLeadingNewlines = function() {
      var i, tag, _i, _len, _ref;
      _ref = this.tokens;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        tag = _ref[i][0];
        if (tag !== 'TERMINATOR') {
          break;
        }
      }
      if (i) {
        return this.tokens.splice(0, i);
      }
    };

    Rewriter.prototype.removeMidExpressionNewlines = function() {
      return this.scanTokens(function(token, i, tokens) {
        var _ref;
        if (!(token[0] === 'TERMINATOR' && (_ref = this.tag(i + 1), __indexOf.call(EXPRESSION_CLOSE, _ref) >= 0))) {
          return 1;
        }
        tokens.splice(i, 1);
        return 0;
      });
    };

    Rewriter.prototype.closeOpenCalls = function() {
      var action, condition;
      condition = function(token, i) {
        var _ref;
        return ((_ref = token[0]) === ')' || _ref === 'CALL_END') || token[0] === 'OUTDENT' && this.tag(i - 1) === ')';
      };
      action = function(token, i) {
        return this.tokens[token[0] === 'OUTDENT' ? i - 1 : i][0] = 'CALL_END';
      };
      return this.scanTokens(function(token, i) {
        if (token[0] === 'CALL_START') {
          this.detectEnd(i + 1, condition, action);
        }
        return 1;
      });
    };

    Rewriter.prototype.closeOpenIndexes = function() {
      var action, condition;
      condition = function(token, i) {
        var _ref;
        return (_ref = token[0]) === ']' || _ref === 'INDEX_END';
      };
      action = function(token, i) {
        return token[0] = 'INDEX_END';
      };
      return this.scanTokens(function(token, i) {
        if (token[0] === 'INDEX_START') {
          this.detectEnd(i + 1, condition, action);
        }
        return 1;
      });
    };

    Rewriter.prototype.addImplicitBraces = function() {
      var action, condition, sameLine, stack, start, startIndent, startIndex, startsLine;
      stack = [];
      start = null;
      startsLine = null;
      sameLine = true;
      startIndent = 0;
      startIndex = 0;
      condition = function(token, i) {
        var one, tag, three, two, _ref, _ref1;
        _ref = this.tokens.slice(i + 1, (i + 3) + 1 || 9e9), one = _ref[0], two = _ref[1], three = _ref[2];
        if ('HERECOMMENT' === (one != null ? one[0] : void 0)) {
          return false;
        }
        tag = token[0];
        if (__indexOf.call(LINEBREAKS, tag) >= 0) {
          sameLine = false;
        }
        return (((tag === 'TERMINATOR' || tag === 'OUTDENT') || (__indexOf.call(IMPLICIT_END, tag) >= 0 && sameLine && !(i - startIndex === 1))) && ((!startsLine && this.tag(i - 1) !== ',') || !((two != null ? two[0] : void 0) === ':' || (one != null ? one[0] : void 0) === '@' && (three != null ? three[0] : void 0) === ':'))) || (tag === ',' && one && ((_ref1 = one[0]) !== 'IDENTIFIER' && _ref1 !== 'NUMBER' && _ref1 !== 'STRING' && _ref1 !== '@' && _ref1 !== 'TERMINATOR' && _ref1 !== 'OUTDENT'));
      };
      action = function(token, i) {
        var tok;
        tok = this.generate('}', '}', token[2]);
        return this.tokens.splice(i, 0, tok);
      };
      return this.scanTokens(function(token, i, tokens) {
        var ago, idx, prevTag, tag, tok, value, _ref, _ref1;
        if (_ref = (tag = token[0]), __indexOf.call(EXPRESSION_START, _ref) >= 0) {
          stack.push([(tag === 'INDENT' && this.tag(i - 1) === '{' ? '{' : tag), i]);
          return 1;
        }
        if (__indexOf.call(EXPRESSION_END, tag) >= 0) {
          start = stack.pop();
          return 1;
        }
        if (!(tag === ':' && ((ago = this.tag(i - 2)) === ':' || ((_ref1 = stack[stack.length - 1]) != null ? _ref1[0] : void 0) !== '{'))) {
          return 1;
        }
        sameLine = true;
        startIndex = i + 1;
        stack.push(['{']);
        idx = ago === '@' ? i - 2 : i - 1;
        while (this.tag(idx - 2) === 'HERECOMMENT') {
          idx -= 2;
        }
        prevTag = this.tag(idx - 1);
        startsLine = !prevTag || (__indexOf.call(LINEBREAKS, prevTag) >= 0);
        value = new String('{');
        value.generated = true;
        tok = this.generate('{', value, token[2]);
        tokens.splice(idx, 0, tok);
        this.detectEnd(i + 2, condition, action);
        return 2;
      });
    };

    Rewriter.prototype.addImplicitParentheses = function() {
      var action, condition, noCall, seenControl, seenSingle;
      noCall = seenSingle = seenControl = false;
      condition = function(token, i) {
        var post, tag, _ref, _ref1;
        tag = token[0];
        if (!seenSingle && token.fromThen) {
          return true;
        }
        if (tag === 'IF' || tag === 'ELSE' || tag === 'CATCH' || tag === '->' || tag === '=>' || tag === 'CLASS') {
          seenSingle = true;
        }
        if (tag === 'IF' || tag === 'ELSE' || tag === 'SWITCH' || tag === 'TRY' || tag === '=') {
          seenControl = true;
        }
        if ((tag === '.' || tag === '?.' || tag === '::') && this.tag(i - 1) === 'OUTDENT') {
          return true;
        }
        return !token.generated && this.tag(i - 1) !== ',' && (__indexOf.call(IMPLICIT_END, tag) >= 0 || (tag === 'INDENT' && !seenControl)) && (tag !== 'INDENT' || (((_ref = this.tag(i - 2)) !== 'CLASS' && _ref !== 'EXTENDS') && (_ref1 = this.tag(i - 1), __indexOf.call(IMPLICIT_BLOCK, _ref1) < 0) && !((post = this.tokens[i + 1]) && post.generated && post[0] === '{')));
      };
      action = function(token, i) {
        return this.tokens.splice(i, 0, this.generate('CALL_END', ')', token[2]));
      };
      return this.scanTokens(function(token, i, tokens) {
        var callObject, current, next, prev, tag, _ref, _ref1, _ref2;
        tag = token[0];
        if (tag === 'CLASS' || tag === 'IF' || tag === 'FOR' || tag === 'WHILE') {
          noCall = true;
        }
        _ref = tokens.slice(i - 1, (i + 1) + 1 || 9e9), prev = _ref[0], current = _ref[1], next = _ref[2];
        callObject = !noCall && tag === 'INDENT' && next && next.generated && next[0] === '{' && prev && (_ref1 = prev[0], __indexOf.call(IMPLICIT_FUNC, _ref1) >= 0);
        seenSingle = false;
        seenControl = false;
        if (__indexOf.call(LINEBREAKS, tag) >= 0) {
          noCall = false;
        }
        if (prev && !prev.spaced && tag === '?') {
          token.call = true;
        }
        if (token.fromThen) {
          return 1;
        }
        if (!(callObject || (prev != null ? prev.spaced : void 0) && (prev.call || (_ref2 = prev[0], __indexOf.call(IMPLICIT_FUNC, _ref2) >= 0)) && (__indexOf.call(IMPLICIT_CALL, tag) >= 0 || !(token.spaced || token.newLine) && __indexOf.call(IMPLICIT_UNSPACED_CALL, tag) >= 0))) {
          return 1;
        }
        tokens.splice(i, 0, this.generate('CALL_START', '(', token[2]));
        this.detectEnd(i + 1, condition, action);
        if (prev[0] === '?') {
          prev[0] = 'FUNC_EXIST';
        }
        return 2;
      });
    };

    Rewriter.prototype.addImplicitIndentation = function() {
      var action, condition, indent, outdent, starter;
      starter = indent = outdent = null;
      condition = function(token, i) {
        var _ref;
        return token[1] !== ';' && (_ref = token[0], __indexOf.call(SINGLE_CLOSERS, _ref) >= 0) && !(token[0] === 'ELSE' && (starter !== 'IF' && starter !== 'THEN'));
      };
      action = function(token, i) {
        return this.tokens.splice((this.tag(i - 1) === ',' ? i - 1 : i), 0, outdent);
      };
      return this.scanTokens(function(token, i, tokens) {
        var tag, _ref, _ref1;
        tag = token[0];
        if (tag === 'TERMINATOR' && this.tag(i + 1) === 'THEN') {
          tokens.splice(i, 1);
          return 0;
        }
        if (tag === 'ELSE' && this.tag(i - 1) !== 'OUTDENT') {
          tokens.splice.apply(tokens, [i, 0].concat(__slice.call(this.indentation(token))));
          return 2;
        }
        if (tag === 'CATCH' && ((_ref = this.tag(i + 2)) === 'OUTDENT' || _ref === 'TERMINATOR' || _ref === 'FINALLY')) {
          tokens.splice.apply(tokens, [i + 2, 0].concat(__slice.call(this.indentation(token))));
          return 4;
        }
        if (__indexOf.call(SINGLE_LINERS, tag) >= 0 && this.tag(i + 1) !== 'INDENT' && !(tag === 'ELSE' && this.tag(i + 1) === 'IF')) {
          starter = tag;
          _ref1 = this.indentation(token, true), indent = _ref1[0], outdent = _ref1[1];
          if (starter === 'THEN') {
            indent.fromThen = true;
          }
          tokens.splice(i + 1, 0, indent);
          this.detectEnd(i + 2, condition, action);
          if (tag === 'THEN') {
            tokens.splice(i, 1);
          }
          return 1;
        }
        return 1;
      });
    };

    Rewriter.prototype.tagPostfixConditionals = function() {
      var action, condition, original;
      original = null;
      condition = function(token, i) {
        var _ref;
        return (_ref = token[0]) === 'TERMINATOR' || _ref === 'INDENT';
      };
      action = function(token, i) {
        if (token[0] !== 'INDENT' || (token.generated && !token.fromThen)) {
          return original[0] = 'POST_' + original[0];
        }
      };
      return this.scanTokens(function(token, i) {
        if (token[0] !== 'IF') {
          return 1;
        }
        original = token;
        this.detectEnd(i + 1, condition, action);
        return 1;
      });
    };

    Rewriter.prototype.indentation = function(token, implicit) {
      var indent, outdent;
      if (implicit == null) {
        implicit = false;
      }
      indent = ['INDENT', 2, token[2]];
      outdent = ['OUTDENT', 2, token[2]];
      if (implicit) {
        indent.generated = outdent.generated = true;
      }
      return [indent, outdent];
    };

    Rewriter.prototype.generate = function(tag, value, line) {
      var tok;
      tok = [tag, value, line];
      tok.generated = true;
      return tok;
    };

    Rewriter.prototype.tag = function(i) {
      var _ref;
      return (_ref = this.tokens[i]) != null ? _ref[0] : void 0;
    };

    return Rewriter;

  })();

  BALANCED_PAIRS = [['(', ')'], ['[', ']'], ['{', '}'], ['INDENT', 'OUTDENT'], ['CALL_START', 'CALL_END'], ['PARAM_START', 'PARAM_END'], ['INDEX_START', 'INDEX_END']];

  exports.INVERSES = INVERSES = {};

  EXPRESSION_START = [];

  EXPRESSION_END = [];

  for (_i = 0, _len = BALANCED_PAIRS.length; _i < _len; _i++) {
    _ref = BALANCED_PAIRS[_i], left = _ref[0], rite = _ref[1];
    EXPRESSION_START.push(INVERSES[rite] = left);
    EXPRESSION_END.push(INVERSES[left] = rite);
  }

  EXPRESSION_CLOSE = ['CATCH', 'WHEN', 'ELSE', 'FINALLY'].concat(EXPRESSION_END);

  IMPLICIT_FUNC = ['IDENTIFIER', 'SUPER', ')', 'CALL_END', ']', 'INDEX_END', '@', 'THIS'];

  IMPLICIT_CALL = ['IDENTIFIER', 'NUMBER', 'STRING', 'JS', 'REGEX', 'NEW', 'PARAM_START', 'CLASS', 'IF', 'TRY', 'SWITCH', 'THIS', 'BOOL', 'NULL', 'UNDEFINED', 'UNARY', 'SUPER', '@', '->', '=>', '[', '(', '{', '--', '++'];

  IMPLICIT_UNSPACED_CALL = ['+', '-'];

  IMPLICIT_BLOCK = ['->', '=>', '{', '[', ','];

  IMPLICIT_END = ['POST_IF', 'FOR', 'WHILE', 'UNTIL', 'WHEN', 'BY', 'LOOP', 'TERMINATOR'];

  SINGLE_LINERS = ['ELSE', '->', '=>', 'TRY', 'FINALLY', 'THEN'];

  SINGLE_CLOSERS = ['TERMINATOR', 'CATCH', 'FINALLY', 'ELSE', 'OUTDENT', 'LEADING_WHEN'];

  LINEBREAKS = ['TERMINATOR', 'INDENT', 'OUTDENT'];

}).call(this);
3/ò‡∞¨¥Ø‰7Xúûºl*wM›ãMWÄÚ”h‰·löx∫È”/à(ö—à¥§`G¬èñT
ŒΩ√xXfc¶SË®\!‹-a Œ<Nªˇé§:"H˛yÚ—8—1à* “˘îøIîæP<0ˇ;K/@“<]:„›L∑‹{ˇí8RÚﬂ∏µ8∫ìmOÔf<÷Jª£ ã“¯°ô%ì5aE•‡‚Ï´ê§·˙8·PzùÕ]†ÓÅc^ÀıÒ<Éq%fOº¢€√üß˜¢SmÀJ¢]OÙ≤É∏œxÎå0›ç)¢Ω˘by>kÄÃ≤¯ÏëE¸A®,óÏaˇ=t‘w˚ÿùXb@‡ø2˜"´~]%ÖˇPØeÚ›â:“Ï/_ªÄÛ4\ÄÓÀœZ¨Jöπ,K^ºŒ¶˝(ﬁ[—g%ΩÃ«Ì ˝we{í∆¥ò@ÿÔË≈›oñÃR0VZ2‘¬©çåóó ´(còÚ£l⁄Êî``}Î@˝√V…‰‚ïá#¶£üËä%{á	¡PüG¸∏!S9±f--^&&]¿?Æ√˘¿≈µFqÃûß+üÔ0Ì∆ÎP ‰ãOò0+$@Äë—®L›Ûá∑º◊§∆†£òtÆmY§çÒÓ•˙sÃÖÙ'LŒKÀâØˆÖIê‘à8ˆH2éI¬ñ5œ–ë~mãYÓ¸È‚?˙¢°"vch3À@PD†s[Ç6™Ïp˜•G;}ºªTÑˇy—!11âK¯Ò2‚$ÅvÍ˝çÅÜA”Ù–‰“@xcËoÉóŒÎ«"©BÁ±÷Êîkˇ–X ≤Âˇ¢˚–	4õãgﬂâ9_Sz±∞gGgêÀ‡ˆy[%D˝≤x¯ç´8”%+åGBxAáÁ‰úƒjÇâöØ¨ìö5î¨à›:4^3Ñ˘‰€…ËÌ©‡Ÿ„È@¶éZÎiU¨»diA=8i¢ﬂ†èC`XÚµÚÆIé-¯{∞«sÍ«÷\P¨‘WÆÇVπVnØá>ë+¯ªgı|∑«éÌ>€û[cUsÒ|;6¸©Yßtqïwl©hı”s®tÌ“41—-ÅeÍù±Ó;óC¿	(©GÂüX@¶û‚sy;I≥6ıoΩVèjEK†c,7Æ
◊1ÏXí∏’ª˜∆€~
d¬6≠¡AÚ+ïùˆ§†®Œúû˝(€·awé}GìPbRüJ∆nnÓhmMâ´+˝ÓÛnÅËaÃ◊/x)vÚı{a=”_1ßÔ5≤Ü›´1»ô∂-t`∂ØH'∑``ÀÔ
^»îó<^û6\Zz=çåÑË¯ºS3√çBü£óT›vm8ÕV˛MA¥=å3øNnóP,¥Ã/B˙EZÜdÜﬁòA‹Ç7ƒ±æ† F˛kÿŸ	M__ïÅ ª‘ˇíRƒÌ"3 x◊◊≠;ó÷<˝î1µ‡èÛIñ≥ﬁà•∑ì=˘\{Åö°Rˆ(Yøp%´cCÅƒ\Ò¯5 Üœ4Ö∏Àò`ÊˇÍ’uj)æØ,ÈÔÓÁ"dÃÇvÇxƒGâ®"¶£' 	´íBŒ*¡h«∂Øoe‡P±0«pµ¢˚˝ÓH)w3«ß⁄4ﬂ”Õß≤úHÎ≥ÄƒΩ&rLˆiMEE˜9vDáÏcJë#}W_›mc™‘ÓmΩ¸sIÌrc@˛≈sl§y∞ŸFÍ≈To.nÁÁ~/ ⁄XÜWÃiæ¿Î X3·>≥=p.—¯¸'ä.à¢QÎT<´’∞∞LHÅ…Œ9"tpﬁ`≈˜ùAˇÕñıÈµªÏ∆Ìq¬3ô‹&Ô›†Àˇ
~?˘êqaÕΩÿ"ëcÖúó®ÿ'ÇúòzM©!r≠ +ùM›|üP√}äNHXQµmÉgp¬cg{DÅc¥ˇà≈â3wL˝µœí“~Jz˛PÖ˛ioFM¸˚˚¨ΩEj§æ(?˜~d%S»Á=D\¡◊%≠#Ë∏Á◊≤H.·Y¡%zTÛÈ≤Ã∏›u¢0Ñ˛Òïò‹l∏øNˇy±8ƒ◊·)[DbÏÄbÏ˜_nù%Í0èE›≈Ω=ü¥t§w[ÒjÁ©Y
6Y™ëß,ÿ¡à≤æ7wü”ÅàT√÷u˚·Á¢Ù≈{µº/ö$ &Ñj];;«]?¸àv≈»¯Ï ‹ÿOﬂçµ™-#ıàn:Ïn÷Ìs-Ô˚⁄Jøèê‘œ§ˇE±óí ∂]"ö∫hùôõß‡°ˆ´oä(âÚ¡Î"˚œ=(âq¿<˚ùû;™abbûÛóç√∏≤ùÛ˚W¿Œd_mçı;)ç&º‚“≠hUù]¡ÒAmd[NX,ÖFƒ/	ç5?˙æì∫’¿,«µB∞å<ïﬂ‰wˇ–’L…∫.8÷ ‰ ◊U.Ôèú∫[îq°¨Á©)ê† ﬁ{–©‹–;1∑”Rò«yúÜ6∏⁄q≥„jWN¿ıWFcÒiÿaÖ“¡]`hgfù∫‰/â®”ñ8ÜÄd$Øå&làÂRrs´go’È4AO»‚nÁtfﬁ∏VÇA‘¬„8MÓÌö):,Ìe]É–∞∫ãI2€cqÅ€æ…?±•<ÅRC»F ™PÒGG√‹X.¯	kRÁ&÷∞j¶ß⁄òe+êıôr∑iÓ√nÑä)âC!N_qàsæ·i™£ìéñ0ÑL%·ŸÜ±3Âi;‚“á’OÓ+wë¿¬Ò:Ü∑ôÂ+<¬ÚqüO’Ú/usH{¯ˇ“fOìı¥%„%.8∂éÚ7é“}˙ö√s?jı…ﬂSÚ’Zï˝_œ Â*jL˘?=b‹.§ÒõÕ*Æpow€Õgƒ¶tŸÍVG~ÛÈ%≈ô	!˝V—À«Úu•¨Æ∫Tqü„WÌ—ƒ
üF	ü‹∏ó&Bk+œΩò™•À&ë*<Õ·ƒ®#rJ<Á&Œ˚ûF£Q¨Î*ÈπPE0∆Õa—ˇ ·9{úò™œ`wc˛≠ä_'„±yı’Îõ|Á„„ç1úÙæ…{+£˘YwéuwGvaph˘Aôßû,ÙP !≤Å
ïXÇ‚µ®ÒøÎÁ;¶(Ù«¶-˜	éHS®<…¬õ—È5ù)&’NÃßÁjõjãƒË}üÇıΩ2ã†«ºâ?ï3ﬁ¸Â»>6p,ÅèÇ/eòÂ~/–πø&¬75è¨≥–PÊÈäc¡ÂÌÕ°©8+ŸjèéQï6+´´…OMjÏMuûP˚üïôP0aU!CØ∑ñtÕÆOqëIZxCΩ)¿E1≥4¡Ó.m6™ÒÑá àN:èj‰ cÆ/OhV{fA∏—ñT)∑†˛BJì£ok\ !9$√ê∂Øﬁ"∏·„y]>≠
ß(∑€≠≥“¬¯õπ`1}I»ËøÊH∫]°7ä©çe'•§©™.»|‡¬ıS∑˛_a§]%„ˇOo˘¥¡LΩ◊∑ñ˜\=‘ ˛Z∆⁄2)€§Ø'˛%á]¥á3<îÑwõ6ÀÒRƒá]o‚`àŒ9(÷b
≈/d9NÚK/	]3¨¯Ã$Ïö0Ôƒ;nSròxãj∆ΩB˚ÿYs¸Í‘#´±2\ÿÒHËE`kÚ‡™œZ2∏›ö¨â£Ä†∆Ö-¯c∂ƒÈdnÔl'ﬂb≤ëf∫{&É¥˜…ùæ‡9∫ª°÷_∂“"¡y«eˆF≥ÁYRO«V0r…üaøs◊ä«¶±M#B.ÃäøøŒWΩ¿dã =ÿj?/µƒI«sdKÉ•Í;¶˚mËÒlˇÍ¥<y≤DQå@÷_Éí∫5¶ã.¬s≈ZtÕ(y#≥)µEF*¬t3-7-Fk"´tÕÒ·ü’ö<è8rWÕ˛œ*Õ°FÒhJ+bÈòªmâ
˙ï$ƒó∏x¶M˛æØ<Måbç€’∑%∞Â}´	÷˙ù1Ë–$\…'ƒøÚêÖ!eæﬂûB≈œç
‹	çÖò2J ±®ªâ§èÔ≈z|D=∏‰Ú§∫*≈D∞dçÖh⁄mHù˚K˝C˝QT´¢—\6@®6É∆L&ßOn.P
ñUÚ:_‹ß‘çnVÙZÀ¿§t˚Wß$^¶ü&ßA∑:§èö0z@FrÁ‰Fèë}jp¯·l5eè†¥j¶µIÑ¬@ÜLç€«π±ÙK˝«Ñ˝˘ç„áÖxxºöç.Ks§YˆK<ª–[ï«ä˙KùÏLÃà4Jp∑‚ñ0«®A◊⁄W